#include "ethernetManager.h"
#include "OSCManager.h"
#include "OSCReceive.h"
#include "../display/colors.h"
#include "../config/jsonManager.h"
#include "../display/pages/globalPage.h"
#include "../display/pages/splashPage.h"
#include "../core/settingsParser.h"
#include "../core/utils.h"

// Variables globales
EthernetUDP showcontrolUdp;
EthernetManager ethernet;

// Buffer global utilisant la constante centralisée
char packetBuffer[UDP_TX_PACKET_MAX_SIZE];

// void EthernetManager::read() {
//   if (processingUDP) {
//     return;
//   }
//   processingUDP = true;
  
//   int packetsReceived = 0;
//   const int MAX_RECEIVE_PER_LOOP = 15;
  
//   while (packetsReceived < MAX_RECEIVE_PER_LOOP) {
//     showcontrolPacketSize = showcontrolUdp.parsePacket();
    
//     if (showcontrolPacketSize > 0 && totalServiceCount > 0) {
//       // Validation avec la constante centralisée
//       if (showcontrolPacketSize < 8 || showcontrolPacketSize > UDP_TX_PACKET_MAX_SIZE - 10) {
//         DEBUG_LOG("Invalid packet size: ");
//         DEBUG_LOGLN(showcontrolPacketSize);
//         showcontrolUdp.flush();
//         packetsReceived++;
//         continue;
//       }
      
//       if (queueCount >= UDP_QUEUE_SIZE - 2) {
//         DEBUG_LOGLN("Queue nearly full - dropping packet");
//         showcontrolUdp.flush();
//         break;
//       }
      
//       // Buffer temporaire utilisant la constante
//       char tempBuffer[UDP_TX_PACKET_MAX_SIZE];
//       memset(tempBuffer, 0, UDP_TX_PACKET_MAX_SIZE);
      
//       int bytesRead = showcontrolUdp.read(tempBuffer, showcontrolPacketSize);
      
//       if (bytesRead == showcontrolPacketSize && bytesRead > 0) {
//         if (tempBuffer[0] == '/' && strlen(tempBuffer) < bytesRead) {
//           if (enqueuePacket(tempBuffer, bytesRead)) {
//             packetsReceived++;
//           } else {
//             DEBUG_LOGLN("ERROR: Enqueue failed!");
//             break;
//           }
//         } else {
//           DEBUG_LOG("Invalid OSC format - first char: '");
//           DEBUG_LOG(tempBuffer[0]);
//           DEBUG_LOGLN("'");
//         }
//       } else {
//         DEBUG_LOGLN("Read error");
//         showcontrolUdp.flush();
//         break;
//       }
//     } else {
//       break;
//     }
//   }
  
//   // Traitement OSC
//   const unsigned long OSC_BUDGET_MS = settings.isRunning ? 30 : 8;
//   const int MAX_PROCESS_PER_LOOP = settings.isRunning ? 25 : 12;
//   unsigned long oscProcessingStart = millis();
//   int packetsProcessed = 0;
  
//   UDPPacket packet;
//   while (packetsProcessed < MAX_PROCESS_PER_LOOP && 
//          (millis() - oscProcessingStart) < OSC_BUDGET_MS &&
//          dequeuePacket(packet)) {
    
//     if (packet.size > 0 && packet.size <= UDP_TX_PACKET_MAX_SIZE - 10 && packet.data[0] == '/') {
//       receiveOSCMsg(packet.data, packet.size);
//     } else {
//       DEBUG_LOG("Invalid packet in queue - size: ");
//       DEBUG_LOGLN(packet.size);
//     }
//     packetsProcessed++;
//   }
  
//   // Diagnostic
//   if (debugOn && (packetsReceived > 8 || packetsProcessed > 8 || queueCount > 20)) {
//     DEBUG_LOG("R:");
//     DEBUG_LOG(packetsReceived);
//     DEBUG_LOG(" P:");
//     DEBUG_LOG(packetsProcessed);
//     DEBUG_LOG(" Q:");
//     DEBUG_LOG(queueCount);
//     DEBUG_LOG("/");
//     DEBUG_LOGLN(UDP_QUEUE_SIZE);
//   }
  
//   if (!settings.isRunning && queueCount < UDP_QUEUE_SIZE / 2) {
//     EthernetBonjour.run();
//   }
  
//   static unsigned long lastNetworkCheck = 0;
//   unsigned long currentMillis = millis();
//   if (currentMillis - lastNetworkCheck >= 750) {
//     lastNetworkCheck = currentMillis;
//     if (Ethernet.linkStatus() != LinkOFF) {
//       checkEthernetConnection();
//       if (activePage == SPLASH_PAGE) showLookingForServer();
//     } else {
//       globalPage.showEthSprite(settings.MIDIConnected, -1);
//     }
//   }
  
//   processingUDP = false;
// }


bool EthernetManager::dequeuePacket(UDPPacket& packet) {
  if (queueCount == 0) {
    return false;
  }
  
  if (queueTail >= UDP_QUEUE_SIZE) {
    queueTail = 0;
    queueCount = 0;
    return false;
  }
  
  // COPIE RAPIDE
  memcpy(packet.data, udpQueue[queueTail].data, udpQueue[queueTail].size);
  packet.size = udpQueue[queueTail].size;
  
  queueTail = (queueTail + 1) % UDP_QUEUE_SIZE;
  queueCount--;
  
  return true;
}

void EthernetManager::setup() {
// IPAddress     localIP(jsonManager.getIPNum(0), jsonManager.getIPNum(1), jsonManager.getIPNum(2), jsonManager.getIPNum(3));
IPAddress manualIP(jsonManager.getIPNum(0), jsonManager.getIPNum(1), jsonManager.getIPNum(2), jsonManager.getIPNum(3));
  DEBUG_LOGLN("ETHERNET SETUP");
    // delay(1000);
  globalPage.showEthSprite(settings.MIDIConnected, -1);
  Ethernet.init(17); 
  if (Ethernet.linkStatus() == LinkOFF) {
    DEBUG_LOGLN("LinkOff");
  } 
  else {
    DEBUG_LOGLN("Link ON");
    if(useDHCP) {
      DEBUG_LOGLN("Start DHCP");
      if (Ethernet.begin(mac) == 0) {
        DEBUG_LOGLN("DHCP Failed");
        Ethernet.begin(mac, manualIP, myDns, gateway, subnet);
      }
      else {
        DEBUG_LOGLN("DHCP Success");
      }
    }
    else {
      DEBUG_LOGLN("Manual IP");
      Ethernet.setLocalIP(manualIP);
      Ethernet.begin(mac, manualIP, myDns, gateway, subnet);
    }
    localIP = Ethernet.localIP();
    int buf[4] = {localIP[0], localIP[1], localIP[2], localIP[3]};
    // showcontrolUdp.begin(showcontrolLocalPort);
    if (showcontrolUdp.begin(showcontrolLocalPort)) {
  DEBUG_LOG("UDP started successfully on port : ");
  DEBUG_LOGLN(showcontrolLocalPort);
} else {
  DEBUG_LOGLN("UDP start failed");
}
    setupEthernetDone = true;
    showIP(buf);
  }
  EthernetBonjour.begin("showcontrolDevice");
  EthernetBonjour.setServiceFoundCallback(serviceFoundCallback);
  discoverOSCServer();
}

void EthernetManager::pingServices(){
  sendOSCShowControl("/showcontrol/ping");
  // for(int index=0; index<2; index++){
  //   // if (index==0) sendOSCAbleset("/getHeartbeat");
  //   if (index==1) sendOSCShowControl("/showcontrol/ping");
  // }
}

void EthernetManager::checkEthernetConnection(){  
  if (Ethernet.linkStatus() == LinkON) {
    globalPage.showEthSprite(settings.MIDIConnected, serviceCounts[0]);
    if (!setupEthernetDone) {
      setup();
    }
  } 
  else {
    DEBUG_LOGLN("LinkOff");
      // showSprite("Link Off", defaultTxtColor, sub2Sprite);
      setupEthernetDone = false;  // Flag the setup to rerun when cable is connected
  }
}


// char packetBuffer[100];  // CORRECTION : 80 bytes au lieu de UDP_TX_PACKET_MAX_SIZE

bool EthernetManager::enqueuePacket(const char* data, uint16_t size) {
  if (queueCount >= UDP_QUEUE_SIZE || data == nullptr || size == 0 || size > 75) {
    return false;
  }
  
  if (queueHead >= UDP_QUEUE_SIZE) {
    queueHead = 0;
    queueCount = 0;
    return false;
  }
  
  // COPIE RAPIDE
  memcpy(udpQueue[queueHead].data, data, size);
  udpQueue[queueHead].size = size;
  
  queueHead = (queueHead + 1) % UDP_QUEUE_SIZE;
  queueCount++;
  
  return true;
}

void EthernetManager::read() {
  // PROTECTION simple contre la réentrance
  if (processingUDP) {
    return;
  }
  processingUDP = true;
  
  // PHASE 1 : Réception RAPIDE - Mettre tous les paquets en queue
  int packetsReceived = 0;
  const int MAX_RECEIVE_PER_LOOP = 25;  // Plus de paquets
  
  while (packetsReceived < MAX_RECEIVE_PER_LOOP) {
    showcontrolPacketSize = showcontrolUdp.parsePacket();
    
    if (showcontrolPacketSize > 0 && totalServiceCount > 0) {
      // PROTECTION : Rejeter les paquets trop grands
      if (showcontrolPacketSize > 75) {
        showcontrolUdp.flush();
        packetsReceived++;
        continue;
      }
      
      // PROTECTION : Queue presque pleine
      if (queueCount >= UDP_QUEUE_SIZE - 1) {
        showcontrolUdp.flush();
        break;
      }
      
      // Buffer temporaire
      char tempBuffer[80];
      int bytesRead = showcontrolUdp.read(tempBuffer, showcontrolPacketSize);
      
      if (bytesRead == showcontrolPacketSize && bytesRead > 0) {
        if (enqueuePacket(tempBuffer, bytesRead)) {
          packetsReceived++;
        } else {
          break;
        }
      } else {
        showcontrolUdp.flush();
        break;
      }
    } else {
      break;
    }
  }
  
  // PHASE 2 : Traitement OSC RAPIDE - Traiter PLUSIEURS messages par boucle
  const unsigned long OSC_BUDGET_MS = settings.isRunning ? 35 : 10;  // Budget généreux
  const int MAX_PROCESS_PER_LOOP = settings.isRunning ? 32 : 16;     // Traiter beaucoup de messages
  unsigned long oscProcessingStart = millis();
  int packetsProcessed = 0;
  
  UDPPacket packet;
  while (packetsProcessed < MAX_PROCESS_PER_LOOP && 
         (millis() - oscProcessingStart) < OSC_BUDGET_MS &&
         dequeuePacket(packet)) {
    
    // TRAITEMENT DIRECT sans validation
    if (packet.size > 0 && packet.size <= 75) {
      receiveOSCMsg(packet.data, packet.size);
    }
    packetsProcessed++;
  }
  
  // DIAGNOSTIC minimal
  if (debugOn && (packetsReceived > 10 || packetsProcessed > 10)) {
    DEBUG_LOG("R:");
    DEBUG_LOG(packetsReceived);
    DEBUG_LOG(" P:");
    DEBUG_LOG(packetsProcessed);
    DEBUG_LOG(" Q:");
    DEBUG_LOG(queueCount);
    DEBUG_LOG("/");
    DEBUG_LOGLN(UDP_QUEUE_SIZE);
  }
  
  // Service discovery seulement si queue pas trop pleine
  if (!settings.isRunning && queueCount < UDP_QUEUE_SIZE / 2) {
    EthernetBonjour.run();
  }
  
  // Maintenance réseau moins fréquente
  static unsigned long lastNetworkCheck = 0;
  unsigned long currentMillis = millis();
  if (currentMillis - lastNetworkCheck >= 750) {  // 750ms au lieu de 500ms
    lastNetworkCheck = currentMillis;
    if (Ethernet.linkStatus() != LinkOFF) {
      checkEthernetConnection();
      if (activePage == SPLASH_PAGE) showLookingForServer();
    } else {
      globalPage.showEthSprite(settings.MIDIConnected, -1);
    }
  }
  
  processingUDP = false;
}

void serviceFoundCallback(const char* type, MDNSServiceProtocol /*proto*/, const char* name, const uint8_t ipAddr[4], unsigned short port, const char* txtContent)
{ 
  // if (ipAddr[0] == 0 && ipAddr[1] == 0 && ipAddr[2] == 0 && ipAddr[3] == 0) {
  //   ethernet.setup(); // Reinitialize Ethernet if IP is zero
  //   return; // Skip if IP address is zero
  // }

  if (NULL == name) {
  } 
  else {
    IPAddress ip(ipAddr[0], ipAddr[1], ipAddr[2], ipAddr[3]);
    DEBUG_LOG("Service found: ");
    DEBUG_LOG(name);
    DEBUG_LOG(" at IP: ");
    DEBUG_LOG(ip);
    DEBUG_LOG(" on port: ");
    DEBUG_LOG(port); 
    if(port > 100 && ipAddr[0] == localIP[0] && ipAddr[1] == localIP[1] && ipAddr[2] == localIP[2]){
      // Vérification directe du nom du service
      if(strcmp(name, "showcontrol") == 0) {
        ethernet.initServer(SHOWCONTROLSRV, ip, port);
      }
      
      if (txtContent) {
        char buf[256];
        char len = *txtContent++; 
        int i=0;
        const char ablesetString[] = "server=ableset";  // const pour optimisation
        DEBUG_LOG("txtContent: ");
        DEBUG_LOG(txtContent);
        DEBUG_LOG(" len: ");
        DEBUG_LOGLN(len);
        while (len) {
          i = 0;
          while (len--)
            buf[i++] = *txtContent++;
          buf[i] = '\0';
          len = *txtContent++;
          
          if(strcmp(buf, ablesetString) == 0) {
            ethernet.initServer(ABLESETSRV, ip, port);
          }
        }
      }
    }
  }
}
